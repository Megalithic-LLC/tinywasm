use alloc::{format, vec::Vec};
use wasmparser::{BlockType, MemArg};

use crate::{
    runtime::{FuncAddr, GlobalAddr, LabelAddr, LocalAddr, TableAddr, TypeAddr},
    Result,
};

/// A WebAssembly Instruction
/// See https://webassembly.github.io/spec/core/binary/instructions.html
/// Currently includes all instructions from the MVP (1.0) spec
pub enum Instruction {
    // Control Instructions
    // See https://webassembly.github.io/spec/core/binary/instructions.html#control-instructions
    Unreachable,
    Nop,
    Block(BlockType),
    Loop(BlockType),
    If(BlockType),
    Else,
    End,
    Br(LabelAddr),
    BrIf(LabelAddr),
    BrTable(Vec<LabelAddr>, LabelAddr), // not to spec, instead of a vector of labels, we have a label and a count
    Return,
    Call(FuncAddr),
    CallIndirect(TypeAddr, TableAddr),

    // Parametric Instructions
    // See https://webassembly.github.io/spec/core/binary/instructions.html#parametric-instructions
    Drop,
    Select,

    // Variable Instructions
    // See https://webassembly.github.io/spec/core/binary/instructions.html#variable-instructions
    LocalGet(LocalAddr),
    LocalSet(LocalAddr),
    LocalTee(LocalAddr),
    GlobalGet(GlobalAddr),
    GlobalSet(GlobalAddr),

    // Memory Instructions
    I32Load(MemArg),
    I64Load(MemArg),
    F32Load(MemArg),
    F64Load(MemArg),
    I32Load8S(MemArg),
    I32Load8U(MemArg),
    I32Load16S(MemArg),
    I32Load16U(MemArg),
    I64Load8S(MemArg),
    I64Load8U(MemArg),
    I64Load16S(MemArg),
    I64Load16U(MemArg),
    I64Load32S(MemArg),
    I64Load32U(MemArg),
    I32Store(MemArg),
    I64Store(MemArg),
    F32Store(MemArg),
    F64Store(MemArg),
    I32Store8(MemArg),
    I32Store16(MemArg),
    I64Store8(MemArg),
    I64Store16(MemArg),
    I64Store32(MemArg),
    MemorySize,
    MemoryGrow,

    // Constants
    I32Const(i32),
    I64Const(i64),
    F32Const(f32),
    F64Const(f64),

    // Numeric Instructions
    // See https://webassembly.github.io/spec/core/binary/instructions.html#numeric-instructions
    I32Eqz,
    I32Eq,
    I32Ne,
    I32LtS,
    I32LtU,
    I32GtS,
    I32GtU,
    I32LeS,
    I32LeU,
    I32GeS,
    I32GeU,
    I64Eqz,
    I64Eq,
    I64Ne,
    I64LtS,
    I64LtU,
    I64GtS,
    I64GtU,
    I64LeS,
    I64LeU,
    I64GeS,
    I64GeU,
    F32Eq,
    F32Ne,
    F32Lt,
    F32Gt,
    F32Le,
    F32Ge,
    F64Eq,
    F64Ne,
    F64Lt,
    F64Gt,
    F64Le,
    F64Ge,
    I32Clz,
    I32Ctz,
    I32Popcnt,
    I32Add,
    I32Sub,
    I32Mul,
    I32DivS,
    I32DivU,
    I32RemS,
    I32RemU,
    I32And,
    I32Or,
    I32Xor,
    I32Shl,
    I32ShrS,
    I32ShrU,
    I32Rotl,
    I32Rotr,
    I64Clz,
    I64Ctz,
    I64Popcnt,
    I64Add,
    I64Sub,
    I64Mul,
    I64DivS,
    I64DivU,
    I64RemS,
    I64RemU,
    I64And,
    I64Or,
    I64Xor,
    I64Shl,
    I64ShrS,
    I64ShrU,
    I64Rotl,
    I64Rotr,
    F32Abs,
    F32Neg,
    F32Ceil,
    F32Floor,
    F32Trunc,
    F32Nearest,
    F32Sqrt,
    F32Add,
    F32Sub,
    F32Mul,
    F32Div,
    F32Min,
    F32Max,
    F32Copysign,
    F64Abs,
    F64Neg,
    F64Ceil,
    F64Floor,
    F64Trunc,
    F64Nearest,
    F64Sqrt,
    F64Add,
    F64Sub,
    F64Mul,
    F64Div,
    F64Min,
    F64Max,
    F64Copysign,
    I32WrapI64,
    I32TruncF32S,
    I32TruncF32U,
    I32TruncF64S,
    I32TruncF64U,
    I64ExtendI32S,
    I64ExtendI32U,
    I64TruncF32S,
    I64TruncF32U,
    I64TruncF64S,
    I64TruncF64U,
    F32ConvertI32S,
    F32ConvertI32U,
    F32ConvertI64S,
    F32ConvertI64U,
    F32DemoteF64,
    F64ConvertI32S,
    F64ConvertI32U,
    F64ConvertI64S,
    F64ConvertI64U,
    F64PromoteF32,
    I32ReinterpretF32,
    I64ReinterpretF64,
    F32ReinterpretI32,
    F64ReinterpretI64,
}

impl TryFrom<wasmparser::Operator<'_>> for Instruction {
    type Error = crate::Error;

    fn try_from(value: wasmparser::Operator<'_>) -> Result<Self> {
        use wasmparser::Operator::*;

        let v = match value {
            Unreachable => Self::Unreachable,
            Nop => Self::Nop,
            Block { blockty } => Self::Block(blockty),
            Loop { blockty } => Self::Loop(blockty),
            If { blockty } => Self::If(blockty),
            Else => Self::Else,
            End => Self::End,
            Br { relative_depth } => Self::Br(relative_depth),
            BrIf { relative_depth } => Self::BrIf(relative_depth),
            BrTable { targets } => {
                let default = targets.default();
                let targets = targets
                    .targets()
                    .map(|t| Ok(t?))
                    .collect::<Result<Vec<u32>>>()?;

                Self::BrTable(targets, default)
            }
            Return => Self::Return,
            Call { function_index } => Self::Call(function_index),
            CallIndirect {
                type_index,
                table_index,
                ..
            } => Self::CallIndirect(type_index, table_index),
            Drop => Self::Drop,
            Select => Self::Select,
            LocalGet { local_index } => Self::LocalGet(local_index),
            LocalSet { local_index } => Self::LocalSet(local_index),
            LocalTee { local_index } => Self::LocalTee(local_index),
            GlobalGet { global_index } => Self::GlobalGet(global_index),
            GlobalSet { global_index } => Self::GlobalSet(global_index),
            MemorySize { .. } => Self::MemorySize,
            MemoryGrow { .. } => Self::MemoryGrow,
            I32Load { memarg } => Self::I32Load(memarg),
            I64Load { memarg } => Self::I64Load(memarg),
            F32Load { memarg } => Self::F32Load(memarg),
            F64Load { memarg } => Self::F64Load(memarg),
            I32Load8S { memarg } => Self::I32Load8S(memarg),
            I32Load8U { memarg } => Self::I32Load8U(memarg),
            I32Load16S { memarg } => Self::I32Load16S(memarg),
            I32Load16U { memarg } => Self::I32Load16U(memarg),
            I64Load8S { memarg } => Self::I64Load8S(memarg),
            I64Load8U { memarg } => Self::I64Load8U(memarg),
            I64Load16S { memarg } => Self::I64Load16S(memarg),
            I64Load16U { memarg } => Self::I64Load16U(memarg),
            I64Load32S { memarg } => Self::I64Load32S(memarg),
            I64Load32U { memarg } => Self::I64Load32U(memarg),
            I32Store { memarg } => Self::I32Store(memarg),
            I64Store { memarg } => Self::I64Store(memarg),
            F32Store { memarg } => Self::F32Store(memarg),
            F64Store { memarg } => Self::F64Store(memarg),
            I32Store8 { memarg } => Self::I32Store8(memarg),
            I32Store16 { memarg } => Self::I32Store16(memarg),
            I64Store8 { memarg } => Self::I64Store8(memarg),
            I64Store16 { memarg } => Self::I64Store16(memarg),
            I64Store32 { memarg } => Self::I64Store32(memarg),
            I32Eqz => Self::I32Eqz,
            I32Eq => Self::I32Eq,
            I32Ne => Self::I32Ne,
            I32LtS => Self::I32LtS,
            I32LtU => Self::I32LtU,
            I32GtS => Self::I32GtS,
            I32GtU => Self::I32GtU,
            I32LeS => Self::I32LeS,
            I32LeU => Self::I32LeU,
            I32GeS => Self::I32GeS,
            I32GeU => Self::I32GeU,
            I64Eqz => Self::I64Eqz,
            I64Eq => Self::I64Eq,
            I64Ne => Self::I64Ne,
            I64LtS => Self::I64LtS,
            I64LtU => Self::I64LtU,
            I64GtS => Self::I64GtS,
            I64GtU => Self::I64GtU,
            I64LeS => Self::I64LeS,
            I64LeU => Self::I64LeU,
            I64GeS => Self::I64GeS,
            I64GeU => Self::I64GeU,
            F32Eq => Self::F32Eq,
            F32Ne => Self::F32Ne,
            F32Lt => Self::F32Lt,
            F32Gt => Self::F32Gt,
            F32Le => Self::F32Le,
            F32Ge => Self::F32Ge,
            F64Eq => Self::F64Eq,
            F64Ne => Self::F64Ne,
            F64Lt => Self::F64Lt,
            F64Gt => Self::F64Gt,
            F64Le => Self::F64Le,
            F64Ge => Self::F64Ge,
            I32Clz => Self::I32Clz,
            I32Ctz => Self::I32Ctz,
            I32Popcnt => Self::I32Popcnt,
            I32Add => Self::I32Add,
            I32Sub => Self::I32Sub,
            I32Mul => Self::I32Mul,
            I32DivS => Self::I32DivS,
            I32DivU => Self::I32DivU,
            I32RemS => Self::I32RemS,
            I32RemU => Self::I32RemU,
            I32And => Self::I32And,
            I32Or => Self::I32Or,
            I32Xor => Self::I32Xor,
            I32Shl => Self::I32Shl,
            I32ShrS => Self::I32ShrS,
            I32ShrU => Self::I32ShrU,
            I32Rotl => Self::I32Rotl,
            I32Rotr => Self::I32Rotr,
            I64Clz => Self::I64Clz,
            I64Ctz => Self::I64Ctz,
            I64Popcnt => Self::I64Popcnt,
            I64Add => Self::I64Add,
            I64Sub => Self::I64Sub,
            I64Mul => Self::I64Mul,
            I64DivS => Self::I64DivS,
            I64DivU => Self::I64DivU,
            I64RemS => Self::I64RemS,
            I64RemU => Self::I64RemU,
            I64And => Self::I64And,
            I64Or => Self::I64Or,
            I64Xor => Self::I64Xor,
            I64Shl => Self::I64Shl,
            I64ShrS => Self::I64ShrS,
            I64ShrU => Self::I64ShrU,
            I64Rotl => Self::I64Rotl,
            I64Rotr => Self::I64Rotr,
            F32Abs => Self::F32Abs,
            F32Neg => Self::F32Neg,
            F32Ceil => Self::F32Ceil,
            F32Floor => Self::F32Floor,
            F32Trunc => Self::F32Trunc,
            F32Nearest => Self::F32Nearest,
            F32Sqrt => Self::F32Sqrt,
            F32Add => Self::F32Add,
            F32Sub => Self::F32Sub,
            F32Mul => Self::F32Mul,
            F32Div => Self::F32Div,
            F32Min => Self::F32Min,
            F32Max => Self::F32Max,
            F32Copysign => Self::F32Copysign,
            F64Abs => Self::F64Abs,
            F64Neg => Self::F64Neg,
            F64Ceil => Self::F64Ceil,
            F64Floor => Self::F64Floor,
            F64Trunc => Self::F64Trunc,
            F64Nearest => Self::F64Nearest,
            F64Sqrt => Self::F64Sqrt,
            F64Add => Self::F64Add,
            F64Sub => Self::F64Sub,
            F64Mul => Self::F64Mul,
            F64Div => Self::F64Div,
            F64Min => Self::F64Min,
            F64Max => Self::F64Max,
            F64Copysign => Self::F64Copysign,
            I32WrapI64 => Self::I32WrapI64,
            I32TruncF32S => Self::I32TruncF32S,
            I32TruncF32U => Self::I32TruncF32U,
            I32TruncF64S => Self::I32TruncF64S,
            I32TruncF64U => Self::I32TruncF64U,
            I64ExtendI32S => Self::I64ExtendI32S,
            I64ExtendI32U => Self::I64ExtendI32U,
            I64TruncF32S => Self::I64TruncF32S,
            I64TruncF32U => Self::I64TruncF32U,
            I64TruncF64S => Self::I64TruncF64S,
            I64TruncF64U => Self::I64TruncF64U,
            F32ConvertI32S => Self::F32ConvertI32S,
            F32ConvertI32U => Self::F32ConvertI32U,
            F32ConvertI64S => Self::F32ConvertI64S,
            F32ConvertI64U => Self::F32ConvertI64U,
            F32DemoteF64 => Self::F32DemoteF64,
            F64ConvertI32S => Self::F64ConvertI32S,
            F64ConvertI32U => Self::F64ConvertI32U,
            F64ConvertI64S => Self::F64ConvertI64S,
            F64ConvertI64U => Self::F64ConvertI64U,
            F64PromoteF32 => Self::F64PromoteF32,
            I32ReinterpretF32 => Self::I32ReinterpretF32,
            I64ReinterpretF64 => Self::I64ReinterpretF64,
            F32ReinterpretI32 => Self::F32ReinterpretI32,
            F64ReinterpretI64 => Self::F64ReinterpretI64,
            _ => {
                return Err(crate::Error::UnsupportedFeature(format!(
                    "Unsupported instruction: {:?}",
                    value
                )))
            }
        };

        Ok(v)
    }
}
